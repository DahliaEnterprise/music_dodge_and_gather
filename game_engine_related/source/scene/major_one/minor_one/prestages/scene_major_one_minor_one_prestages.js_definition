var get_next_float = null;
get_next_float = function(string, begin_index, end_index)
{
  let float_as_string = "";
	
	return float_as_string;
}

scene_major_one_minor_one_prestages = function(timepassed_since_last_game_tick)
{
  if(scene_prestage == 1)
	{
	  xhr_request_initialize(1, "GET", "http://shastaexchange.com/music_dodge_and_gather/models/user_interface/progress_bar_orange/progress_bar_orange_border.xyz_coordinates", []);
	  scene_prestage = 2;
	}else if(scene_prestage == 2)
	{
	  if(xhr_request_stage[xhr_request_object_index] == 3)
		{
	    //loaded progress bar orange
		  let split_data_string = xhr_response_text[xhr_request_object_index].split(",");
			scene_major_one_minor_one_models["ui_progress_bar_orange_border"] = new Float32Array(xhr_response_text[xhr_request_object_index].split(","));
			
			//
		  xhr_clear_memory();
		
		  //next prestage
		  scene_prestage = 3;
		}else{
		  //error/abort check response here.
		}
	}else if(scene_prestage == 3)
	{
	  xhr_request_initialize(1, "GET", "http://shastaexchange.com/music_dodge_and_gather/models/user_interface/progress_bar_orange/progress_bar_orange_border.xy_texture_coordinates", []);
	  scene_prestage = 4
	}else if(scene_prestage == 4)
	{
	  if(xhr_request_stage[xhr_request_object_index] == 3)
		{
	    //loaded progress bar orange
			scene_major_one_minor_one_texture_coordinates["ui_progress_bar_orange_border"] = new Float32Array(xhr_response_text[xhr_request_object_index].split(","));
			
		  //
		  xhr_clear_memory();
		
		  //next prestage
		  scene_prestage = 5;
		}else{
		  //error/abort check response here.
		}
	}else if(scene_prestage == 5)
	{
	  xhr_request_initialize(2, "GET", "http://shastaexchange.com/music_dodge_and_gather/images/user_interface/progress_bar_orange/progress_bar_orange_style_border.rgba", []);
	  scene_prestage = 6;
	}else if(scene_prestage == 6)
	{
	  if(xhr_request_stage[xhr_request_object_index] == 3)
		{
	    //loaded progress bar orange
		  
			scene_major_one_minor_one_image_rgba["ui_progress_bar_orange_border"] = new Uint8Array(xhr_response_data[xhr_request_object_index]);
			//
		  xhr_clear_memory();
		
		  //next prestage
		  scene_prestage = 7;
		}else{
		  //error/abort check response here.
		}
	}else if(scene_prestage == 7)
	{
	  //Clear the viewport(screen) before drawing a new frame. (you will always do it this way, the only rare times you will add on to an already drawn frame is maybe an Operating System window(or UI) that goes on top of everything else and usually only when there is no alpha or moving objects).
         opengles.clearColor(0.0, 0.0, 0.0, 1.0);
         opengles.viewport(0, 0, opengles.viewportWidth, opengles.viewportHeight);
         opengles.clear(opengles.COLOR_BUFFER_BIT);
				 
	  
	  let square_vertex = scene_major_one_minor_one_models["ui_progress_bar_orange_border"];  /*new Float32Array([
			                                    1.0, 1.0, 0.0,
-1.0, 1.0, 0.0,
-1.0, -0.1, 0.0
			                                  ]);*/
																				
			 let square_texture_coordinates =  scene_major_one_minor_one_texture_coordinates["ui_progress_bar_orange_border"] /* new Float32Array([
			                                                  1.0, 1.0,
0.0, 1.0,
0.0, 1.0
			                                               ]);
													*/
			let square_total_rows = 3;		
			 
	
	
		 let square_vertex_manipulated = square_vertex;
         
		 
		   	 let square_and_texturecoordinates_vertex_manipulated	= combine_vertex_and_texture_coordinates(square_vertex_manipulated, square_texture_coordinates, square_total_rows);
				 
				 console.log(square_and_texturecoordinates_vertex_manipulated);
				 
				 
        let square_vertex_opengles = opengles.createBuffer();
         opengles.bindBuffer(opengles.ARRAY_BUFFER, square_vertex_opengles);
         opengles.bufferData(opengles.ARRAY_BUFFER, square_and_texturecoordinates_vertex_manipulated, opengles.STATIC_DRAW);
             
				 
				 let float_size = square_and_texturecoordinates_vertex_manipulated.BYTES_PER_ELEMENT;
					 
				 let attribute_position_coordinates = opengles.getAttribLocation(shader_program_texture, "a_Position");
            opengles.vertexAttribPointer(attribute_position_coordinates, 3, opengles.FLOAT, false, (float_size * 5), (float_size * 0));
            opengles.enableVertexAttribArray(attribute_position_coordinates);
        
        
       let  attribute_texture_coordinates = opengles.getAttribLocation(shader_program_texture, 'a_TexCoord');
            opengles.vertexAttribPointer(attribute_texture_coordinates , 2, opengles.FLOAT, false, (float_size * 5), (float_size * 3));
            opengles.enableVertexAttribArray(attribute_texture_coordinates);
            
						
						
				opengles.pixelStorei(opengles.UNPACK_FLIP_Y_WEBGL, 1);
             
             
			  //alert the gpu where to open and ready for unloading of texture data to gpu memory.
				let opengles_texture_buffer = opengles.createTexture();
        opengles.activeTexture(opengles.TEXTURE0);
             
        opengles.bindTexture(opengles.TEXTURE_2D, opengles_texture_buffer);
						 
			 let u_Sampler = opengles.getUniformLocation(shader_program_texture, 'u_Sampler');
             //flag which sampler to use with uniform.
             opengles.uniform1i(u_Sampler, 0);
             
             opengles.texParameteri(opengles.TEXTURE_2D, opengles.TEXTURE_MIN_FILTER, opengles.LINEAR);
              
             //upload image data from motherboard ram to gpu ram through cpu instructions.
            // opengles.texImage2D(opengles.TEXTURE_2D, 0, opengles.RGBA, opengles.RGBA, opengles.UNSIGNED_BYTE, image_data);
          opengles.texImage2D(opengles.TEXTURE_2D, 0, opengles.RGBA, 16, 16, 0, opengles.RGBA, opengles.UNSIGNED_BYTE, scene_major_one_minor_one_image_rgba["ui_progress_bar_orange_border"]);
					
					//tell gpu what vertex to draw now that the texture to draw with it has been activated.
             opengles.useProgram(shader_program_texture);
             opengles.drawArrays(opengles.TRIANGLES, 0, square_total_rows);
						 
						 
	
	
	
	
						 
	}
	
}
